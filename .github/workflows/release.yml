name: release
run-name: Tag, Build, and Create Release
description: |
  Tags the release commit when a release PR is merged into main,
  builds the release artifacts, and creates a release.
on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  tag-build-release:
    if: |
      github.event.pull_request.merged == true && 
      startsWith(github.event.pull_request.head.ref, 'release-')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      # Get tag name
      - name: Get tag name
        run: |
          # Get tag name from branch name
          PR_BRANCH=${{ github.event.pull_request.head.ref }}
          echo "TAG=$PR_BRANCH" >> $GITHUB_ENV

      # Load package.json into memory
      - name: Load package.json
        id: package
        uses: zoexx/github-action-json-file-properties@release
        with:
          file_path: "./package.json"

      # Load the manifest into memory
      - name: Load system manifest
        id: manifest
        uses: zoexx/github-action-json-file-properties@release
        with:
          file_path: "./src/system.json"

      # Set up variables
      - name: Set up vars
        run: |
          echo "ZIP_NAME=cosmere-rpg-$TAG.zip" >> $GITHUB_ENV
          echo "DOWNLOAD_URL=https://github.com/${{github.repository}}/releases/download/$TAG/cosmere-rpg-$TAG.zip" >> $GITHUB_ENV

      # Verify manifest
      - name: Verify manifest
        run: |
          # Verify that the manifest version matches the tag
          if [[ ! $TAG == release-$MANIFEST_VERSION ]]; then
            echo "Manifest version does not match tag name."
            echo "Manifest version: $MANIFEST_VERSION"
            echo "Tag name: $TAG"
            echo "Please update the manifest version to match the tag name."
            exit 1
          fi

          # Verify the package version matches the manifest version
          if [[ "$MANIFEST_VERSION" != "$PACKAGE_VERSION" ]]; then
            echo "Package version does not match manifest version."
            echo "Package version: $PACKAGE_VERSION"
            echo "Manifest version: $MANIFEST_VERSION"
            echo "Please update the version in package.json to match the manifest version."
            exit 1
          fi

          # Verify that the download URL matches the release asset
          if [[ ! "${{ env.DOWNLOAD_URL }}" == $MANIFEST_DOWNLOAD ]]; then
            echo "Download URL does not match release asset."
            echo "Download URL: $DOWNLOAD_URL"
            echo "Release asset: $MANIFEST_DOWNLOAD"
            echo "Please update the manifest download URL to match the release asset."
            exit 1
          fi
        env:
          MANIFEST_VERSION: ${{ steps.manifest.outputs.version }}
          MANIFEST_DOWNLOAD: ${{  steps.manifest.outputs.download }}
          PACKAGE_VERSION: ${{ steps.package.outputs.version }}

      # Create tag
      - name: Create Tag
        run: |
          git tag $TAG
          git push origin $TAG

      # Set up node 
      - name: Use Node 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Install dependencies
      - name: NPM install
        run: |
          npm ci

      # Build
      - name: Build release
        run: |
          npm run build:release

      # Fetch latest release
      - name: Fetch latest release
        id: latest_release
        uses: cardinalby/git-get-release-action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          latest: true
          doNotFailIfNotFound: true

      # Determine whether this is a patch or a major/minor release
      - name: Determine release type
        id: release_type
        run: |
          if [[ -z "${{ steps.latest_release.outputs.tag_name }}" ]]; then
            echo "RELEASE_TYPE=major-minor" >> $GITHUB_ENV
            echo "RELEASE_NOTES=./src/release-notes.md" >> $GITHUB_ENV
            echo "No previous releases found. Release is a major or minor release."
          else
            # Get the current version info
            CURRENT_VERSION=$MANIFEST_VERSION
            CURRENT_VERSION_MAJOR=$(echo $CURRENT_VERSION | cut -d'.' -f1)
            CURRENT_VERSION_MINOR=$(echo $CURRENT_VERSION | cut -d'.' -f2)
            CURRENT_VERSION_PATCH=$(echo $CURRENT_VERSION | cut -d'.' -f3)

            # Get the latest version info
            LATEST_VERSION=$(echo ${{steps.latest_release.outputs.tag_name}} | cut -d'-' -f2)
            LATEST_VERSION_MAJOR=$(echo $LATEST_VERSION | cut -d'.' -f1)
            LATEST_VERSION_MINOR=$(echo $LATEST_VERSION | cut -d'.' -f2)
            LATEST_VERSION_PATCH=$(echo $LATEST_VERSION | cut -d'.' -f3)

            # Determine the release type
            if [[ $CURRENT_VERSION_MAJOR -gt $LATEST_VERSION_MAJOR ]] || [[ $CURRENT_VERSION_MINOR -gt $LATEST_VERSION_MINOR ]]; then
              echo "RELEASE_TYPE=major-minor" >> $GITHUB_ENV
              echo "RELEASE_NOTES=./src/release-notes.md" >> $GITHUB_ENV
              echo "Release is a major or minor release."
            else
              echo "RELEASE_TYPE=patch" >> $GITHUB_ENV
              echo "RELEASE_NOTES=./src/patch-notes.md" >> $GITHUB_ENV
              echo "Release is a patch release."
            fi
          fi
        env:
          MANIFEST_VERSION: ${{ steps.manifest.outputs.version }}

      # Create release
      - name: Create release
        uses: ncipollo/release-action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          name: ${{ github.event.pull_request.title }}
          tag: ${{ env.TAG }}
          bodyFile: ${{ env.RELEASE_NOTES }}
          artifacts: "./${{ env.ZIP_NAME }}"
          draft: true